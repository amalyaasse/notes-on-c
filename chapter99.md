# Միակապ ցուցակների կառուցումը

*Միակապ ցուցակը* իրար կապված հանգույցների շղթա է։ Ամեն մի հանգույցը պարունակում է նվազագույնը երկու դաշտ. հանգույցը բնութագրող բանալի՝ `key`, և հաջորդ հանգույցին կապող ցուցիչ՝ `next`։

```
+-----+------+
| key | next-|-->
+-----+------+
```

Սահմանեմ `node` (հանգույց) ստրուկտուրան, որի `key` դաշտը `double` տիպի է, իսկ `next` դաշտը `struct node` օբյեկտի ցուցիչ է։

```c
struct node {
  double key;        /* բնութագրող */
  struct node* next; /* կապ */
};
```

Օրինակ, երեք հանգույցներից բաղկացած միակապ ցուցակն ունի հետևյալ տեսքը.

```
 +-----+---+    +-----+---+    +-----+---+    +---+
 | 1.2 |  -+--->| 3.4 |  -+--->| 5.6 |  -+--->| / |
 +-----+---+    +-----+---+    +-----+---+    +---+
                \-----------------v---------------/
    head                         tail
```

Ընդունված է *կապակցված ցուցակի* առաջին տարրն անվանել *գլուխ* (head), իսկ առաջինից բացի հաջորդ տարրերի ցուցակը՝ *պոչ* (tail)։ Այսուհետ «ցուցակ» ասելով ես նկատի կունենամ մի ցուցիչ, որը պարունակում է `head`-ի հասցեն։ Կարելի է նույնիսկ `struct node*` տիպի համար սահմանել մի նոր հոմանիշ։ 

```c
typedef struct node* silist;
```

Ասացի, որ ցուցակը բնույթով դինամիկ օբյեկտ է։ Այսինքն, ծրագրի կատարման ընթացքում ցուցակին կարելի է ավելացնել նոր հանգույցներ և ցուցակից հեռացնել հանգույցները։ Բնականաբար, կոմպիլյացիայի ժամանակ չի կարող հայտնի լինել օգտագործվող հանգույցների քանակը, և կոմպիլյատորը չի կարող անհրաժեշտ հիշողություն հատկացնել *ստատիկ* տիրույթում։

Սահմանեմ `create_node` ֆունկցիան, որը ստանում է `double` արժեք և վերադարձնում է մի նոր հանգույցի հասցե, որի `key` դաշտում գրված է տրված արժեքը, իսկ `next` դաշտն ունի `NULL` արժեքը։

```c
struct node* create_node( double val )
{
  struct node* nd = malloc( sizeof(struct node) );
  nd->key = val;
  nd->next = NULL;
  return nd;
}
```

`malloc` ֆունկցիան դինամիկ տիրույթում առանձնացնում է պահանջված չափի հիշողության հատված և վերադարձնում է դրա առաջին բայթի հասցեն։ Այստեղ `node` ստրուկտուրայի չափը որոշել եմ C լեզվի `sizeof` օպերատորով։ `sizeof`-ը ստանում է տիպի անուն կամ փոփոխական և վերադարձնում է դրա չափը բայթերով։

Եթե `malloc` ֆունկցիան համակարգից պահանջում է հիշողության նոր բաժին, ապա `free` ֆունկցիան համակարգին է վերադարձնում այդ զբաղեցրած տիրույթը։ Այն արգումենտում ստանում է դինամիկ ստեղծված օբյեկտի հասցե։ Սահմանեմ `destroy_node` ֆունկցիան, որ ազատում է տրված `node` ստրուկտուրայի նմուշի զբաղեցրած հիշողությունը։ Այդ ֆունկցիան պարունակում է `free` դրադարանային ֆունկցիայի միակ կանչ։

```c
void destroy_node( struct node* nd )
{
  free(nd);
}
```

Սա հանգույցի մասին։ Հիմա պատմեմ, թե ինչպես է հանգույցներից ցուցակ կառուցվում։ Պարզ է, որ զրոյական ցուցիչը կատարելու է դատարկ ցուցակի դերը։

```c
silist e0 = NULL; /* դատարկ ցուցակ */
```

Ցուցակի սկզբից `k` բանաալին ունեցող նոր հանգույց ավելացնելու համար սահմանեմ `add_to_front` ֆունկցիան։

```c
silist add_to_front( double k, silist list )
{
  struct node no = create_node( k );
  no->next = list;
  return no;
}
```

Այստեղ օգտագործված է *չփոփոխվող* (immutable) օբյեկտի գաղափարը, այն է՝ ոչ թե փոփոխվել է տրված `list` օբյեկտը, այլ կառուցվել է նոր ցուցակ, որի գլուխը `k` բանալին պարունակող նոր ստեղծված հանգույցն է, իսկ պոչը տրված `list` ցուցակն է։ `e0` ցուցակին `1.2`, `3.4` և `5.6` թվերը պարունակող հանգույցներն ավելացնելու համար պետք է կատարել հետևյալ հրամանները․

```c
e0 = add_to_front( 5.6, e0 );
e0 = add_to_front( 3.4, e0 );
e0 = add_to_front( 1.2, e0 );
```

Հիմա, եթե արտածեմ այս ցուցակը, ապա կստանամ `1.2 3.4 5.6` հաջորդականությունը։

Բայց ինչպե՞ս արտածել ցուցակը։ Նորից կարելի է գրել ռեկուրսիվ ֆունկցիա։ Օրինակ, այսպես․

```c
void print_list_rec( silist list )
{
  if( list != NULL ) {
    printf( "%lf ", list->key ); /* արտածել գլխի բանալին */
    print_list_rec( list->next ); /* արտածել պոչը */
  }
}
```

Ավելի պարզ, իհարկե, հնարավոր էլ չէ պատկերացնել։ Բայց ուզում եմ այս առիթն օգտագործել ու պատմել C լեզվում *նախապայմանով ցիկլի* կազմակերպման `while` հրամանի մասին։

```
while( ⟨կրկնման պայման⟩ )
  ⟨կատարվող մարմին⟩
```

Այս ցիկլի `⟨կատարվող մարմին⟩` հրամանների բլոկը կատարվում է այնքան ժամանակ, քանի դեռ ճշմարիտ է `⟨կրկնման պայման⟩` արտահայտության արժեքը։

`while` հրամանն օգտագործելով կարող եմ գրել ցուցակն արտածող ֆունկցիա՝ ռեկուրսիվի փոխարեն կիրառելով իտերատիվ մոտեցում․

```c
void print_list_iter( silist list )
{
  while( list != NULL ) {
    printf( "%lf ", list->key ); /* արտածել բանալին */
    list = list->next; /* անցնել հաջորդ հանգույցին */
  }
}
```

Ցուցակի առաջին տարրը հեռացնելու համար սահմանեմ `add_to_front` ֆունկցիային սիմետրիկ `remove_from_front` ֆունկցիան։

```c
silist remove_from_front( silist list )
{
  if( list == NULL ) return NULL; /* երբ ցուցակը դատարկ է */
  silist tail = list->next; /* պահել պոչը */
  destroy_node( list ); /* քանդել գլխի հանգույցը */
  return tail;
}
```

`add_to_front` և `remove_from_front` ֆունկցիաները չեն փոխում իրենց արգումենտը։ Այս ստրատեգիան պարզեցնում է ֆունկցիաների սահմանումները և հնարավորություն է տալիս ավելի մոտենալ ծրագրավորման ֆունկցիոնալ ոճին։ 

Ես ուզում եմ սահմանել ցուցակի հանգույցներն ավելացնող ու հեռացնող ֆունկցիաներ, որոնք փոփոխում են իրենց արգումենտում տրված ցուցակը։

Նախ՝ ցուցակի սկզբում հանգույց ավելացնող ֆունկցիան, որը այնքան էլ չի տարբերվում վերը բերված տարբերակից։

```c
void add_to_front( double k, silist* list )
{
  struct node* no = create_node( k );
  no->next = *list;
  *list = no;
}
```

Այս ֆունկցիայի երկրորդ պարամետրը հայտարարված է որպես ցուցիչ։ Դա հնարավորություն է տալիս փոխել նրա արժեքը, այսինքն փոփոխություն կատարել տրված ցուցակում։ `1.2`, `3.4` և `5.6` թվերի ցուցակը `add_to_front` այս ֆունկցիայով կառուցելու համար պետք է գրել հետևյալը.

```c
struct node* e1 = NULL;
add_to_front( 5.6, &e1 );
add_to_front( 3.4, &e1 );
add_to_front( 1.2, &e1 );
```

Ցուցակի վերջից արժեք ավելացնելը նույնպես շատ պարզ է. եթե ցուցակը դատարկ է, ապա նոր ստեղծված հանգույցը դառնում է նրա առաջին տարրը, հակառակ դեպքում արժեքն ավելացվում է ցուցակի պոչից։

```c
void add_to_back( double k, silist* list )
{
  if( NULL == *list )
    *list = create_node( k );
  else
    add_to_back( k, &((*list)->next) );
}
```



*{Հանգույցի հեռացնելը ցուցակից}*
*{Արժեքի որոնում}*


***
*{Շատ անհաջող շարադրված նյութ ստացվեց։}* *{Պետք է հիմնովին վերանայել։}*


