# Զրույց VI

Հարգելի՛ ընթերցող։

Այս զրույցում ես խոսելու եմ մի թեմայի մասին, առանց որի դժվար կլիներ կառուցել քիչ թե շատ պիտանի ծրագրեր։ Այդ թեման հիշողության *դինամիկ կառավարումն* է։ Որպես ցուցադրման օրինակ ես ընտրել եմ բնույթով դինամիկ օբյեկտ՝ բոլորին լավ հայտնի միակապ ցուցակը։

*Միակապ ցուցակը* ցուցիչներիվ իրար կապված հանգույցների շղթա է։ Ամեն մի հանգույցը պարունակում է նվազծագույնը երկու դաշտ. հանգույցը բնութագրող բանալի՝ `key`, և հաջորդ հանգույցին կապող ցուցիչ՝ `next`։

```
+-----+------+
| key | next-|-->
+-----+------+
```

Սահմանեմ `node` (հանգույց) ստրուկտուրան, որի `key` դաշտը `double` տիպի է, իսկ `next` դաշտը `struct node` օբյեկտի ցուցիչ է։

```c
struct node {
  double key;        /* բնութագրող */
  struct node* next; /* կապ */
};
```

Օրինակ, երեք հանգույցներից բաղկացած միակապ ցուցակն ունի հետևյալ տեսքը.

```
 +-----+---+    +-----+---+    +-----+---+    +---+
 | 1.2 |  -+--->| 3.4 |  -+--->| 5.6 |  -+--->| / |
 +-----+---+    +-----+---+    +-----+---+    +---+
                \-----------------v---------------/
    head                         tail
```

Ընդունված է *կապակցված ցուցակի* առաջին տարրն անվանել *գլուխ* (head), իսկ առաջինից բացի հաջորդ տարրերի ցուցակը՝ *պոչ* (tail)։ Այսուհետ «ցուցակ» ասելով ես նկատի կունենամ մի ցուցիչ, որը պարունակում է `head`-ի հասցեն։ Դատարկ ցուցակն էլ, պարզ է, որ կնշանակվի `NULL` զրոյական ցուցիչով։ 

Ասացի, որ ցուցակը բնույթով դինամիկ օբյեկտ է։ Այսինքն, ծրագրի կատարման ընթացքում ցուցակին կարելի է ավելացնել նոր հանգույցներ և ցուցակից հեռացնել հանգույցները։ Բնականաբար, կոմպիլյացիայի ժամանակ չի կարող հայտնի լինել օգտագործվող հանգույցների քանակը, և կոմպիլյատորը չի կարող անհրաժեշտ հիշողություն հատկացնել *ստատիկ* տիրույթում։

Սահմանեմ `create_node` ֆունկցիան, որը ստանում է `double` արժեք և վերադարձնում է մի նոր հանգույցի հասցե, որի `key` դաշտում գրված է տրված արժեքը, իսկ `next` դաշտն ունի `NULL` արժեքը։

```c
struct node* create_node( double val )
{
  struct node* nd = malloc( sizeof(struct node) );
  nd->key = val;
  nd->next = NULL;
  return nd;
}
```

`malloc` ֆունկցիան դինամիկ տիրույթում առանձնացնում է պահանջված չափի հիշողության հատված և վերադարձնում է դրա առաջին բայթի հասցեն։ Այստեղ `node` ստրուկտուրայի չափը որոշել եմ C լեզվի `sizeof` օպերատորով։ `sizeof`-ը ստանում է տիպի անուն կամ փոփոխական և վերադարձնում է դրա չափը բայթերով։

`malloc` ֆունկցիայի հակառակ գործն է անում `free` ֆունկցիան. եթե `malloc`-ը համակարգից պահանջում է հիշողության նոր բաժին, ապա `free`-ն համակարգին է վերադարձնում այդ զբաղեցրած տիրույթը։ Այն արգումենտում ստանում է դինամիկ ստեղծված օբյեկտի հասցե։ 

Սահմանեմ `destroy_node` ֆունկցիան, որ ազատում է տրված `node` ստրուկտուրայի նմուշի զբաղեցրած հիշողությունը։ Այդ ֆունկցիան պարունակում է `free` դրադարանային ֆունկցիայի միակ կանչ։

```c
void destroy_node( struct node* nd )
{
  free(nd);
}
```

*{Նոր հանգույց ցուցակի սկզբում, վերջում}*
*{Հանգույցի հեռացնելը ցուցակից}*
*{Արժեքի որոնում}*

***

Մինչև հիմանական սահմանումներին անցնելը, ուզում եմ խոսել մի քանի կազմակերպչական հարցերի մասին։

Երբ C լեզվով նախագծվում է ինչ-որ գրադարան, դրա հայտարարությունները գրում են `.h` վերջավորությամբ ֆայլում, իսկ իրականացումները՝ `.c` վերջավորությամբ ֆայլերում։ Դրա օրինակ է `math.h` ֆայլը (կարելի է նայել դրա մեջ և համոզվել որ այնտեղ միայն հայտարարություներ են)։

Ես նույնպես միակապ ցուցակների համար ստեղծելու եմ `slist.h` ֆայլը, որի մեջ գրելու եմ ստրուկտուրաների ու ֆունկցիաների հայտարարությունները։ Նաև ստեղծելու եմ `slist.c` ֆայլը, որի մեջ էլ գրելու եմ միակապ ցուցակի ֆունկցիաների իրականացումը։

/* ․հ ֆայլի կառուցվածքը */


***

```c
extern struct node* create_node( double );
extern void destroy_node( struct node* );
```

Ցուցակը կառուցելու համար նախատեսել եմ `construct` ֆունկցիան։

```c
extern struct node* construct( double, struct node* );
```

Ցուցակի առաջին տարրը վերցնելու համար նախատեսել եմ `head` ֆունկցիան։

```c
extern double head( struct node* );
```

Ցուցակի պոչը ստանալու համար նախատեսել եմ `tail` ֆունկցիան։

```c
extern struct node* tail( struct node* );
```

*{Ցուցակը տպելու ռեկուրսիվ և իտերատիվ (while) եղանակների մասին։}*

