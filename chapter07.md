# Զրույց VII

Հարգելի՛ ընթերցող։

Այս զրույցը C լեզվի զանգվածների մասին է։

*Զանգվածը* նույն անունն ունեցող միատեսակ տարրերի անընդհատ շարք է։ Զահնվածի մի որևէ տարրին կարելի է դիմել զրոյից սկսվող ինդեքսի միջոցով։ Օրինակ, եթե `a`-ն `N` տարրեր ունեցող զանգված է, ապա նրա առաջին տարրին կարելի է դիմել `a[0]` գրառմամբ, իսկ վերջին տարրին՝ `a[N-1]` գրառմամբ։ C լեզվում որևէ տիպի օբյեկտների զանգվածը հայտարավում է փոփոխականի անունից հետո `[` և `]` փակագծերում տարրերի քանակը նշելով։ Օրինակ, առանց նշանի ամբողջ թվերի տաս տարրերից բաղկացած զանգված կարող ենք սահմանել հետևյալ հրամանով․

```c
unsigned int v0[10];
```

Զանգվածը հայտարարելիս կարելի է միանգամից արժեքավորել նրա տարրերը։ Օրինակ.

```c
int v1[5] = { 1, 2, 3, 4, 5 };
```

հրամանով սահմանված է իրական թվերի զանգված՝ հինգ երկարությամբ, և դրա տարրերն արժեքավորված են `1..5` թվերով։ 

Համանման ձևով են սահմանվում նաև բազմաչափ զանգվածները։ Օրինակ, `2⨯3` չափի մատրիցը կարելի է սահմանել ու արժեքավորել այսպես.

```c
double m0[2][3] = { {1.1, 1.2, 1.3}, {2.2, 2.3, 2.4} };
```

Եթե զանգվածը սահմանելիս արժեքավորման ցուցակում տրված են ավելի քիչ արժեքներ, քան զանգվաի չափն է, ապա պակասող արժեքների փոխարեն զանգվածում գրվում են զրոներ։ Օրինակ,

```c
long double v2[10] = { 1.2, 2.3 };
```

սահմանումից հետո եթե վերցնեմ `v2` զանգվածի հինգերորդ տարրը, ապա կտեսնեմ, որ այն զրո է։

C լեզվում զանգվածի անունը *ցուցիչ* է իր առաջին տարրին, իսկ զանգվածի տարրերին կարելի է դիմել ոչ միայն `[]` *ինդեքսավորման* գործողությամբ, այլ նաև ցուցիչների հետ թվաբանական գործողություններ կատարելով։ Օրինակ, `v1` զանգվածի երրորդ տարրն արտածելու համար կարող ենք գրել հետևյալ երկու համարժեք հրամանները․

```c
printf( "%d\n", v1[2] );
printf( "%d\n", *(v1 + 2) );
```0.


Զանգվածների հետ աշխատանքը ցուցադրելու համար ուզում եմ բերել մի օրինակ՝ նորից օգտագործելով դեկարտյան կետը։ Ենթադրենք դեկարտյան կետերի `points` զանգվածը պարունակում է հարթության վրա ցրված `N` կետ։ Պետք է գրել մի ֆունկցիա, որը վերադարձնում է տրված կետերը որպես գագաթներ ունեցող բեկյալի երկարությունը։

Հիշեցնեմ `point` ստրուկտուրայի հայտարարությունը․

```c
struct point {
  double x;
  double y;
};
```

Բեկյալի երկարությունը նրա հանգույցների երկարությունների գումարն է։ Ամեն մի հանգույցի երկարությունը նրա ծայրակետերի հեռավորությունն է, որը հաշվում եմ Պյութագորասի բանաձևով։

```c
double distance( struct point a, struct point b )
{
  double dx = a.x - b.x;
  double dy = a.y - b.y;
  return sqrt( dx * dx + dy * dy );
}
```

Բեկյալի երկարությունը հաշվող `length` ֆունկցիան կարող է ունենալ հետևյալ հայտարարությունը․

```c
double length( struct point[], int );
```

Սա ասում է, որ `length` անունով ֆունկցիան արգումենտում սպասում է `struct point` օբյեկտների զանգված և մի ամբողջ թիվ, որը զանգվածի տարրերի քանակն է։ Ֆունկցիայի վերադարձրած `double` արժեքն էլ կետի ինդեքսն է։

`N` գագաթներ (`N-1` հանգույցներ) ունեցող բեկյալի երկարությունը ես կհաշվեմ ռեկուրսիվ եղանակով՝ ըստ գագաթների քանակի։ Եթե զանգվածում մեկ տարր է, ապա բեկյալը հանգույցներ չունի և նրա երկարությունը զրո է։ Եթե բեկյալն ունի `n` գագաթներ, ապա նրա երկարությունը կհաշվեմ՝ իրար գումարելով առաջին `n-1` գագաթներց կազմված բեկյալի երկարությունն ու `n-1`-րդ և `n`-րդ գագաթներն ունեցող հանգույցի երկարությունը։ *{Անհաջող նախադասություն ստացվեց}*

```c
double length( struct point ps[], int nm )
{
  if( nm == 1 )
    return 0.0;
  return distance( ps[nm-1], ps[nm-2] ) 
       + length( ps, nm-1 );
}
```

Կարծես թե ճիշտ է, բայց ստուգելը չի խանգարի։ Սահմանեմ մի վեկտոր, որը պարունակում է `f(x)=x` ուղղին պատկանող `(0,0)`, `(1,1)`, `(2,2)` և `(3,3)` կետերը, ապա հաշվեմ ու արտածեմ այդ կետերով կազմված բեկյալի (ուղիղ գծի) երկարությունը։

```c
int main()
{
  struct point points[] = { {0,0}, {1,1}, {2,2}, {3,3} };
  double res = length( points, 4 );
  printf( ">> %lf\n", res );
  return 0;
}
```

`points` զանգվածը սահմանելիս ես նրա չափը բացահայտ չեմ նշել։ Եթե առկա է զանգվածն արժեքավորող ցուցակ, ապա կոմպիլյատորը զանգվածի չափը պարզում է այդ ցուցակում տրված արժեքների քանակով։ Տվյալ դեպքում թվարկված են չորս կետի կոորդինատներ, հետևաբար `points` զանգվածի չափը `4` է։


C լեզվում *տողը* ներկայացվում է որպես `char` տիպի նիշերի զանգված, որի վերջին տարրը `0` է (կամ `\0` նիշը)։ Օրինակ, հետևյալ սահմանումները համարժեք են․

```c
char h0[] = { 'H', 'e', 'l', 'l', 'o', '!', '\0' };
char h1[] = "Hello!";
char* h2 = "Hello!";
```

Երբ նիշերի զանգվածն արժեքավորվում է *տողային լիտերալով* (`"․․․"` գրառմամբ), զանգվածի վերջին `'\0'` նիշն ավտոմատ ավելացվում է։ 

Տողերի հետ աշխատող ֆունկցիաների հայտարարությունները C լեզվի ստանդարտ գրադարանի `string.h` ֆայլում են։ Օրինակ, 

