# Զրույց VII

Հարգելի՛ ընթերցող։

Դժվար կլիներ կառուցել քիչ թե շատ պիտանի ծրագրեր, եթե C լեզուն թույլ տար օգտագործել միայն _ավտոմատ_ և _ստատիկ_ փոփոխականներ կամ զանգվածներ։ Ավելի հաճախ են հանդիպում այն դեպքերը, երբ անհրաժեշտ հիշողության չափը հայտնի է դառնում ծրագրի կատարման ընթացքում։ 

Օրինակ, ինչպե՞ս գրել ծրագիր, որն օգտագործողից պահանջում է ներմուծել իրական թվերի հաջորդականություն, ապա արտածում է այդ նույն թվերը՝ հակառակ կարգով։ Վատագույն դեպքն այն է, որ հայտարարել հնարավորինս մեծ զանգված և նրա մեջ լցնել թվերը։ Բայց միշտ հնարավոր է, որ օգտագործողի խելքին փչի ներմուծել ավելի շատ թվեր, քան զանգվածի չափն է։ ՈՒրեմն պետք են միջոցներ, որոնք կհատկացնեն տվյալ պահի համար անհրաժեշտ հիշողություն և կազատի այդ հիշողությունը, երբ որ այն պետք չլինի։

C լեզվի ստանդարտ գրադարանի `stdlib.h` ֆայլում հայտարարված են հիշողության հետ աշխատող `calloc`, `realloc`, `malloc` և `free` ֆունկցիաները, որոնք ես կօգտագործեմ այս զրույցի օրինակներում։

Նախ սահմանեմ `size` ամբողջ թիվը, որը ցույց է տալու թվերի զանգվածի ընթացիկ չափը և `numbers` _դինամիկ_ զանգվածը, որում պահվելու են ներմուծված թվերը։

```c
int size = 16;
double* numbers = calloc( size, sizeof(double) );
```

`calloc` ֆունկցիայի առաջին արգումենտը տարրերի քանակն է, իսկ երկրորդը՝ մեկ տարրի չափը։ Ֆունկցիան վերադարձնում է զրոներով արժեքավորված հիշողության տիրույթ՝ տրված քանակով և տրված չափի տարրերի համար։

Հետո `while` հրամանով կազմակերպեմ մի անվերջ ցիկլ, որի մարմնում կարդալու եմ թվերը։ Այդ անվերջ ցիկլն ավարտվելու է այն դեպքում, երբ `scanf` ֆունկցիան վերադարձնում է `EOF` (end of file) արժեքը։

```c
int count = 0; /* ներմուծված թվերի հաշվիչ */
while( 1 ) {
  int res = scanf( "%lf", &numbers[count] );
  if( res == EOF ) break;
  if( ++count == size ) {
    size *= 2;
    numbers = realloc( numbers, size * sizeof(double) );
  }
}
```

Ցիկլի հերթական իտերացիայում, `count` փոփոխականի արժեքը համեմատվում է զանգվածի ընթացիկ չափի հետ։ Եթե դրանք հավասար են, ուրեմն զանգվածի բոլոր դիրքերը զբաղված են․ պետք է մեծացնել նրա չափը։ `size *= 2` արտահայտությամբ, որը համարժեք է `size = size * 2` հրամանին, ես կրկնապատկում եմ զանգվածի չափը որոշող փոփոխականի արժեքը։ Իսկ `numbers` զանգվածը ընդլայնում եմ `realloc` ֆունկցիայով։ `realloc` ֆունկցիան ընդլայնում է `malloc`, `calloc` կամ `realloc` ֆունկցիաներով առանձնացված հիշողության տիրույթը։ Այն իր արգումենտում ստանում է ընդլայնվելիք հիշողության հասցեն և նոր չափը։

Երբ ներմուծման ցիկլը ավարտվում է (Linux համակարգրում `EOF` սիմվոլ ներածվում է ստեղնների `Ctrl+D` համադրմամբ), մեկ այլ `while` ցիկլով արտածում եմ `numbers` զանգվածի պարունակությունը։

```c
while( --count >= 0 )
  printf( "%lf\n", numbers[count] );
```

Եվ վերջապես․ պետք է ազատել ծրագրի աշխատանքի ընթացքում զբաղեցրած դինամիկ հիշողությունը։ `free` ֆունկցիան ազատում և համակարգին է վերադարձնում `malloc`, `calloc` կամ `realloc` ֆունկցիաներով առանձնացված հիշողության տիրույթը։

```c
free( numbers );
```

Բացի `calloc` և `realloc` ֆունկցիաներից հիշողության նոր տիրույթ կարելի է առանձնացնել նաև `malloc` ֆունկցիայով։ Այն վերադարձնում է հիշողության տիրույթ, որի չափը ստանում է իր միակ արգումենտով։ Իմ բերած օրինակում `calloc` ֆունկցիայի կիրառությունը կարելի է փոխարինել `malloc` ֆունկցիայի հետևյալ կիրառությամբ․

```c
double* numbers = malloc( size * sizeof(double) );
```

Այն տարբերությամբ նաև, որ `malloc` ֆունկցիան զրոներով չի արժեքավորում առանձնացված տիրույթը։

Եթե ինչ-որ պատճառով ձախողվում է պահանջվող չափի հիշողության տիրույթի առանձնացումը, ապա `malloc`, `calloc` և `realloc` ֆունկցիաները վերադարձնում են `NULL` արժեքը։ Եվ այս փաստը պետք է հաշվի առնել ու ծրագրերը լրացել համապատասխան ստուգումներով։ Օրինակ․

```c
double* numbers = calloc( size, sizeof(double) );
if( numbers == NULL ) {
  puts( "Հնարավոր չէ հատկացնել պահանջվող հիշողությունը։" );
  exit( 1 );
}
```

----
_{Տեքստը լրացնել C11 ստանդարտում ներմուծված `aligned_alloc` ֆունկցիայի մասին մեկնաբանությամբ։}_

