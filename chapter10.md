# Զրույց X։ Գրադարան ստեղծելու մասին

Այս զրույցում ես պատմում եմ, թե ինչպես ստեղծել _դինամիկ_ և _ստատիկ_ գրադարաններ, ապա դրանք օգտագործել ծրագրում։ Եվ քանի որ նպատակս գրադարաններ ստեղծման տեխնիկայի ցուցադրումն է, շատ բարդ բաների հետևից չեմ ընկնի և որպես օրինակ կներկայացնեմ միայն մեկ ֆունկցիա պարունակող գրադարան։ _{հետագայում տեքստն ընդլայնել մի քանի ֆայլերից բաղկացած օրինակի համար}_

Ստեղծեմ `ni.c` (numeric integral) ֆայլը, որը պարունակում է գրադարանի իրականացումը։ Այս ֆայլում սահմանված են մոտավոր ինտեգրալի հաշվման Սիմպսոնի բանաձևը՝ `simpson` ֆունկցիան, թվի բացարձակ արժեքը հաշվող `dabs` ֆունկցիան և `epsilon` հաստատունը, որի օգնությամբ որոշվում է հաշվարկների ճշտությունը։

```c
static const double epsilon = 1e-5;

static double dabs( double v )
{
  return (v < 0 ? -v : v);
}

static double simpson( double(*f)(double), double a, double b )
{
  return ((b - a) / 6) * (f(a) + 4 * f((a + b) / 2) + f(b));
}
```

Այս երեք անունների սահմանումն էլ սկսվում են `static` ծառայողական բառով՝ ցույց տալու, որ նրանք պետք է տեսանելի լինեն միայն `ni.c՝ կոմպիլյացվող միավորի սահմանում։ _{մանրամասներ linker-ի մասին}_

Գրադարանի իրականացման `ni.c` ֆայլում սահմանված է նաև `integral` ֆունկցիան, որը «բաժանիր և տիրիր» մոտեցմամբ հաշվում է ինտեգրալը։ Եթե ինտեգրման միջակայքի երկարությունը փոքր է նախապես սահմանված `epsilon` թվից, ապա այդ հատվածի վրա կիրառվում է Սիմպսոնի բանաձևը։ Հակառակ դեպքում միջակայքը տրոհվում է երկու հավասար մասերի և մասերից ամեն մեկի վրա ռեկուրսիվ կիրառվում է `integral` ֆունկցիան՝ որպես արդյունք վերադարձնելով ստացված գումարը։ _{վերաձևակերպել անհաջող նախադասությունը}_
 
```c
double integral( double(*f)(double), double a, double b )
{
  if( b - a < epsilon )
    return simpson( f, a, b );
  double m = (a + b) / 2.0;
  return integral( f, a, m ) + integral( f, m, b );
}
```

Որպեսզի այս ֆունկցիան հնարավոր լինի օգտագործել այլ ծրագրերում, ստեղծեմ նաև `ni.h` հայտարարությունների ֆայլը։ Այն պարունակելու է միայն `integral` ֆունկցիայի հայտարարությունը։

```c
#ifndef NUMERIC_INTEGRAL
#define NUMERIC_INTEGRAL

extern double integral( double(*)(double), double, double );

#endif
```

Ֆունկցիայի հայտարարությունից առաջ գրված `extern` ծառայողական բառն ուզում է ասել, թե `integral` ֆունկցիան սահմանված է մի որևէ այլ տեղ (գուցե հենց նույն ֆայլում)։ 

Նախ ցույց տամ, թե ինչպես պետք է `ni.c` ֆայլից ստանալ ստատիկ գրադարան։ Դրա համար պետք է ֆայլը կոմպիլյացնել և ստեղծել _օբյեկտային ֆայլ_, այնուհետև օբյեկտային ֆայլից (կամ ֆայլերից, եթե դրանք մի քանի հատ են) ստանալ ստատիկ գրադարանի արխիվը։

`.c` ֆայլը կոմպիլյացնելու և համապատասխան օբյեկտային ֆայլը ստանալու համար կոմպիլյատորը պետք է աշխատեցնել `-c` պարամետրով։

```bash
$ gcc -c ni.c -o ni.o
```

Ստատիկ գրադարանի ֆայլը, որի անունը պետք է ունենա `lib` նախածանցը, իսկ ընդլայնումը պետք է լինի `.a`, ստեղծվում է `ar`արխիվացման ծրագրի օգնությամբ։

```bash
$ ar rcs libni.a ni.o
```

Հիմա ցույց տամ, թե ինչպես եմ այս գրադարանն օգտագործելու։ Ենթադրենք ուզում եմ `-1..1` միջակայքի վրա հաշվել _x²_ և _x³_ ֆունկցիաների մոտավոր ինտեգրալը։ Ստեղծեմ `ex0.c` ֆայլը հետևյալ պարունակությամբ։

```c
#include <stdio.h>
#include "ni.h"

double sqr(double x) { return x * x; }
double cub(double x) { return x * x * x; }

int main()
{
  double r0 = integral( &sqr, -1, 1 );
  printf( "> %lf\n", r0 );
  double r1 = integral( &cub, -1, 1 );
  printf( "> %lf\n", r1 );
  return 0;
}
```

Այստեղ օգտագործել եմ `ni` (numeric integral) գրադարանի միակ `integral` ֆունկցիան։ Սա նշանակում է, որ `ex0.c` ֆայլի կոմպիլյացիայի և կապակցման ժամանակ պետք է կապերի խմբագրիչին հուշել `ni` գրադարանի մասին։

```bash
$ gcc ex0.c -L. -lni
```

Այստեղ `-L` պարամետրով նշվում է, թե որտեղ պետք է որոնել գրադարանը, իսկ `-l` պարամետրով՝ նշվում է գրադարանի անունը։ Եթե `-L` պարամետրով չնշվի, որ գրադարանը գտնվում է ընթացիկ պանակում, ապա կապերի խմբագրիչը կասի, որ չի կարողանում գտնել `ni` գրադարանը։ Բանն այն է, որ կապերի խմբագրիչի համար սահմանված են կոնկրետ տեղեր, որտեղ այն պետք է փնտրի գրադարանները։
