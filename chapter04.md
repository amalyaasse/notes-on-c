# Զրույց IV

Հարգելի՛ ընթերցող։

Նախորդ զրույցներում իմ բերած օրինակները շատ պարզ էին․ ծրագիրը սկսվում էր `main` ֆունկցիայից, կանչվում էր այս կամ այն ֆունկցիան, կատարվում էին հաջորդական գործողություններ ու ծրագրի կատարումն ավարտվում էր։ Իսկ ի՛նչ անել, երբ պետք է ծրագրի տրամաբանությունը ղեկավարել ներմուծված կամ ձևավորված տվյալներից կախված։ Օրինակ, ինչպե՞ս սահմանեմ թվի նշանը որոշող `sign` ֆունկցիան։ Այն պետք է արգումենտում ստացած դրականների թվերի համար վերադարձնի՝ `1`, բացասականների համար՝ `-1`, իսկ զրոյի համար՝ `0`։ Պարզ է, որ ֆունկցիայի այդպիսի վարքը մոդելավորելու համար հարկավոր է *ճյուղավորման* հրաման։

C լեզվում ճյուղավորումները կազմակերպվում են `if` հրամանով.

```c
if( ⟨condition⟩ ) ⟨then-block⟩ else ⟨else-block⟩
```

Եթե *ճշմարիտ* է `⟨condition⟩` պայմանը, ապա կատարվում են `⟨then-block⟩` հրամանները, հակառակ դեպքում կատարվում են `⟨else-block⟩` հրամանները։ Եթե պայմանի *կեղծ* լինելու դեպքում ոչինչ անել պետք չէ, ապա `else` ծառայողական բառը և նրան հաջորդող `⟨else-block⟩` հրամանները կարելի է չգրել։ Օրինակ, այսպես.

```c
if( argc == 1 )
  usage();
```

`usage` ֆունկցիան կանչվում է միայն այն դեպքում, երբ `argc` փոփոխականը հավասար է մեկի։ 

Արդեն տեղին է հիշատակել C լեզվի համեմատման գործողությունների մասին։ Դրանք վեցն են և նախատեսված են թվերի ու նիշերի համեմատման համար, իսկ `==` և `!=` գործողությունները օգտագործվում են նաև ցուցիչների հավասարությունն ու անհավասարությունը ստուգելու համար։

Գործողություն | Նշանակություն
:--------------:|:------------------
`==`            | հավասար է
`!=`            | հավասար չէ
`>`             | մեծ է
`>=`            | մեծ է կամ հավասար
`<`             | փոքր է
`<=`            | փոքր է կամ հավասար

Հիմա վերը հիշատակված `sign` ֆունկցիայի մասին։ Այն կարող է ունենալ հետևյալ տեսքը.

```c
int sign( double num )
{
  int res = 0; /* զրոյական դեպք */
  if( num < 0 ) /* եթե բացասական է */
    res = -1;
  else if( num > 0 ) /* այլապես եթե դրական է */
    res = 1;
  return res;
}
```

Բայց, քանի որ `return` հրամանն իր կիրառման կետում ավարտում է ֆունկցայի աշխատանքը, `sign` ֆունկցիան կարելի է գրել ավելի պարզ ձևով։

```c
int sign( double num )
{
  if( num < 0 ) return -1; /* բացասական */
  if( num > 0 ) return 1;  /* դրական */
  return 0; /* զրո */
}
```


Բացի `if-else` ճյուղավորման հրամանից, C լեզուն ունի նաև `switch` ընտրության հրամանը, որը թույլ է տալիս ընտրություն կատարել արտահայտության արժեքներ մեջ և ամեն մի արժեքին համապատասխանեցնել հրամանների առանձին հաջորդականություն։ Նրա ընդհանուր տեսքն այսպիսինն է.

```c
switch( ⟨expression⟩ ) {
  case ⟨value_1⟩:
    ⟨block_1⟩
  case ⟨value_2⟩:
    ⟨block_2⟩
  ...
  defailt:
    ⟨block_!⟩
}
```

Այստեղ եթե `⟨expression⟩ == ⟨value_1⟩`, ապա կատարվում է `⟨block_1⟩`-ը, եթե `⟨expression⟩ == ⟨value_2⟩`, ապա՝ `⟨block_2⟩`-ը և այդպես շարունակ։ Եթե `⟨expression⟩`-ի արժեքը ոչ մի `case` տարբերակի չի համընկնում, կատարվում է `default` ծառայողական բառից հետո գրված կոդը։ 

Օրինակ, սահմանեմ `day_of_week` ֆունկցիան, որն արգումենտում ստանում է ամբողջ թիվ և արտածում է համապատասխան շաբաթվա օրվա անունը։

```c
void day_of_week( int day )
{
  switch( day ) {
    case 1:
      puts( "երկուշաբթի" );
      break;
    case 2:
      puts( "երեքշաբթի" );
      break;
    case 3:
      puts( "չորեքշաբթի" );
      break;
    case 4:
      puts( "հինգշաբթի" );
      break;
    case 5:
      puts( "ուրբաթ" );
      break;
    case 6:
      puts( "շաբաթ" );
      break;
    case 7:
      puts( "կիրակի" );
      break;
    default:
      puts( "այդպիսի համարով օր չկա" );
  }
}
```


Նույն `day_of_week` ֆունկցիան սահմանեմ նաև `if-else` հրամանի օգնությամբ.

```c
void day_of_week( int day )
{
  if( day == 1 )
    puts( "երկուշաբթի" );
  else if( day == 2 )
    puts( "երեքշաբթի" );
  else if( day == 3 )
    puts( "չորեքշաբթի" );
  else if( day == 4 )
    puts( "հինգշաբթի" );
  else if( day == 5 )
    puts( "ուրբաթ" );
  else if( day == 6 )
    puts( "շաբաթ" );
  else if( day == 7 )
    puts( "կիրակի" );
  else
    puts( "այդպիսի համարով օր չկա" );
}
```

Երևի մեկնաբանությունների կարիք չկա. հերթով դիտարկվում են `day` արգումենտի արժեքները և ամեն մեկի համար արտածվում է համապատասխան բառը։ Ամենավերջին `else` ճյուղը կատարվում է այն դեպքում, երբ `day` փոփոխականի արժեքը `[1..7]` միջակայքից չէ։




