# Զրույց II

Հարգելի՛ ընթերցող։

Եթե դու կարդում ես իմ այս երկրորդ զրույցը, ուրեմն, ենթադրում եմ, որ առաջին զրույցի թեման քեզ անտարբեր չի թողել, և դու որոշել ես շարունակել ծանոթությունդ C ծրագրավորման լեզվի հետ։ Այս երկրորդ զրույցում ես պատմելու եմ C լեզվի փոփոխականների, դրանց հայտարարման ու արժեքավորման մասին։ Ինչպես նաև այն մասին, թե ինչպես փոփոխականին վերագրել ստեղնաշարից ներմուծված արժեքը։

C լեզվով գրված ամեն մի ծրագիր, բացառությամբ պարզագույն դեպքերի, պարունակում է *փոփոխականներ*, կարդում և փոփոխում է դրանց արժեքները։ Յուրաքանչյուր փոփոխական, որ հանդիպում է ծրագրում, պետք է նախապես *հայտարարված* լինի։ Փոփոխականի հայտարարությունը բաղկացած է նրա *տիպը* հայտարարող ծառայողական բառից և փոփոխականի *անունից*։ Օրինակ,

```c
double a;      /* a-ն կրկնակի ճշտությամբ իրական թիվ է */
float b, c;    /* b-ն և c-ն սովորական ճշտության իրական թվեր են */
int d0, d1;    /* d0-ն և d1-ը ամբողջ թվեր են */
char sym;      /* sym-ը նիշ է (character) */
long int e1a;  /* e1a-ն երկար ամբողջ թիվ է */
```

Այստեղ `double`, `float`, `int`, `char` և `long` բառերը C լեզվի ծառայողական բառեր են, իսկ `a`, `b`, `c`, `d0`, `d1`, `sym` և `e1a` բառերը՝ C լեզվի իդենտիֆիկատորներ։

Փոփոխականի տիպով որոշվում է հիշողությունում նրա զբաղեցրած բայթերի քանակը և նրա հետ կատարվող թույլատրելի գործողությունները։ Օրինակ, իմ համակարգում `int` տիպ ունեցող փոփոխականը զբաղեցնում է 4 բայթ, իսկ `double` տիպ ունեցող փոփոխականը՝ 8 բայթ։ Փոփոխականին հատկացված հիշողության բայթերից առաջինի համարը կոչվում է փոփոխականի *հասցե*։

Հենց հայտարարության մեջ կարելի է փոփոխականին արժեք վերագրել։ Օրինակ, 

```c
int count = 0;       /* հայտարարել count ամբողջաթիվ փոփխականը՝ 0 արժեքով */
double pi = 3.1415;  /* հայտարարել pi իրական փոփխականը՝ 3.1415 արժեքով */
char c = 'A';        /* հայտարարել c նիշային փոփոխականը՝ «A» արժեքով */
```

Ընդհանրապես, ծրագրավորման *լավ ոճ* է համարվում, երբ փոփոխականին արժեք է վերագրվում հայտարարության հետ միասին։ Բայց փոփոխականին նոր արժեք կարելի է տալ նաև `=` *վերագրման* գործողությամբ։ Օրինակ, 

```c
double a0, a1, b0;  /* a0-ն, a1-ը և b0-ն իրական թվեր են */
a0 = 2.36;          /* a0-ին վերագրել 2.36 */
a1 = 4.1;           /* a1-ին վերագրել 4.1 */
b0 = a0 + a1;       /* b0-ին վերագրել a0-ի և a1-ի գումարը */
```


Ես ուզում եմ ցույց տալ ու մեկնաբանել մի ծրագիր, որն օգտագործողից պահանջում է ներմուծել հարթության մի որևէ կետի դեկարտյան կոորդինատները և արտածում է նույն այդ կետի բևեռային կոորդինատները։ 

Պարզ է, որ կետի դեկարտյան կոորդինատները ներկայացնելու համար պետք է հայտարարել `x` և `y` իրական փոփոխականները, ապա դրանց արժեքները կարդալ ստեղնաշարից։

```c
double x = 0.0, y = 0.0;
scanf( "%lf", &x );  /* կարդալ իրական թիվ և վերագրել x-ին */
scanf( "%lf", &y );  /* նույնը՝ y-ի համար */
```

C լեզվի ստանդարտ գրադարանի `scanf` (scan formated - ֆորմատավորված ընթերցում) ֆունկցիան ստանդարտ ներածման հոսքից կարդում է նիշերի հաջորդականություն և այն ձևափոխում է ըստ տրված ֆորմատի։ `scanf` ֆունկցիայի առաջին արգումենտը ֆորմատավորման տողն է, որ կարող է պարունակել `%` նիշով սկսվող ֆորմատավորման հրահանգներ։ `%` նիշին հաջորդող նիշերով որոշվում է, թե ինչպես պետք է մեկնաբանվեն կարդացած տվյալները։ Օրինակ, եթե գրված է `%d`, ամա սա նշանակում է, որ հոսքից կարդացած նիշերը պետք է դիտարկել որպես տասական (decimal) թիվ։ Եթե գրված է `%f`, ապա՝ սովորական ճշտության իրական (float) թիվ։ Ֆորմատավորման հրահանգներին համապատասխան ձևափոխված տվյալները գրվում են `scanf` ֆունկցիայի երկրորդ և հաջորդ արգումենտներով տրված հասցեներում։ Օրինակ.

```c
scanf( "%lf", &x );
```

արտայահտության մեջ տրված `"%lf"` ֆորմատը հուշում է, որ պետք է կարդալ երկար իրական թիվ (*l* - long, *f* - float) և կարդացած արժեքը գրել `x` փոփոխականի զբաղեցրած հասցեում։ `x`-ից առաջ գրված `&` նիշը փոփոխականի հասցեն վերցնելու գործողությունն է։ *Հասցեն* հիշողության այն բջջի համարն է, որը հայտարարության արդյունքում հատկացվել է տվյալ փոփոխականին։ `scanf` ֆունկցիային փոխանցվում է փոփոխականի հասցեն՝ այն տեղը, որտեղ պետք է գրել ներածման ստանդարտ հոսքից կարդացած տվյալները։

> `scanf` և `printf` ֆունկցիաների ֆորմատավորման հրահանգների մասին ես դեռ պատմելու շատ առիթներ կունենամ։ Առայժմ իմացիր, որ `"$lf"` ֆորմատով կարելի է կարդալ `double` արժեք։

`x` և `y` փոփոխականների արժեքները կարդացող `scanf` ֆունկցիայի երկու կանչերը կարելի է միավորել մեկի մեջ՝ `"%lf"` ֆորմատը փոխարինելով `"%lf,%lf"` ֆորմատով։ Սա նշանակում է, որ `scanf` ֆունկցիան ստեղնաշարից կարդալու է իրարից ստորակետով բաժանված երկու `double` արժեք։

```c
double x = 0.0, y = 0.0;
scanf( "%lf,%lf", &x, &y );  /* կարդալ երկու իրական թվեր և վերագրել x-ին ու y-ին */
```

Դե քանի որ `scanf` ֆունկցիայի ֆորմատավորման տողը պարունակում է երկու ֆորմատավորման հրահանգ, ապա պետք է տալ կարդացած արժեքները գրելու երկու հասցե `&x` և `&y`։

Եթե պետք լինի օգտագործողին ստիպել, որ նա կետի կոորդինատները ներմուծի `(` և `)` փակագծերի մեջ վերցրած, ապա կարելի է ֆորմատավորման տողը գրել `"(%lf,%lf)"` տեսքով։ Բառացիորեն սա կարելի է կարդալ հետևյալ կերպ. «կարդալ `(` նիշը, կարդալ `double` թիվ, կարդալ `,` նիշը, կարդալ `double` թիվ, կարդալ `)` նիշը»։

Կետի `x` *աբսցիսի* և `y` *օրդինատի* արժեքները կարդալուց հետո պետք է հաշվել նրա բևեռային կոորդինատները՝ `ρ` *շառավիղը* և `φ` *ազիմուտը*։ Կոորդինատների բևեռային համակարգում `ρ`-ն որոշվում է որպես կետի հեռավորությունն բևեռից, իսկ `φ`-ն՝ որպես շառավղի և բևեռային առանցքի կազմած անկյուն։

C լեզվով դեկարտյանից բևեռային կոորդինատների արտապատկերում կարող եմ գրել հետևյալ արտահայտություններով։

```c
double rho = sqrt( x * x + y * y );
double phi = atan2( y, x );
```

`sqrt` ֆունկցիան վերադարձնում է արգումենտի քառակուսի արմատը, իսկ `atan2` ֆունկցիան վերադարձնում է `0` սկզբնակետ և `(x,y)` վերջնակետ ունեցող վեկտորի և աբսցիցների առանցքի կազմած անկյունը ռադիաններով։ Այս երկու ֆունկցիաներն էլ սահմանված են C լեզվի ստանդարտ գրադարանի `math.h` ֆայլում։

`rho` և `phi` արժեքների հաշվարկից հետո պարզապես պետք է արտածել դրանք․

```c
puts( "Բևեռային կոորդնատներն են․ " );
printf( "ρ = %lf, φ = %lf\n", rho, phi );
```

`printf` ֆունկցիայում նույնպես օգտագործվել են `"%lf"` ֆորմատավորման հրահանգները։ Քանի որ `printf` ֆունկցիան իր արգումենտները չի փոխում, այստեղ նրան փոխանցում ենք `x` և `y` փոփոխականների արժեքները, այլ ոչ թե հասցեները։

Վերջ։ Մնում է այս ամենը հավաքել `main` ֆունկցիայի մեջ, կոմպիլյացնել, գործարկել ու տեսնել արդյունքները։ Ես ամբողջ ծրագիրը գրել եմ `prog02.c` ֆայլի մեջ։

```c
#include <stdio.h>
#include <math.h>

int main()
{
  double x = 0.0, y = 0.0;
  puts( "Ներածիր դեկարտյան կոորդինատները x,y․ " );
  scanf( "%lf,%lf", &x, &y );

  double rho = sqrt( x * x + y * y );
  double phi = atan2( y, x );

  puts( "Բևեռային կոորդնատներն են․ " );
  printf( "ρ = %lf, φ = %lf\n", rho, phi );

  return 0;
}
```

`#include` դիրեկտիվով կցվել են `stdio.h` և `math.h` ֆայլերը։ Առաջինից օգտագործվում են `puts`, `scanf` և `printf` ֆունկցիաները, իսկ երկրորդից՝ `sqrt` և `atan2` ֆունկցիաները։

Երբ ես փորձում եմ `prog02.c` ֆայլը կոմպիլյացնել այնպես, ինչպես դա արեցի առաջին զրույցում նկարագրված `prog01.c` ֆայլի հետ․

```bash
$ clang prog02.c -o prog2.c
```

ապա ստանում եմ մի հաղորդագրություն, որն ասում է, թե linker ծրագիրը՝ *կապերի խմբագրիչը* չի գտել `sqrt` և `atan2` ֆունկցիաները։ 

```
/tmp/prog02-80b543.o: In function `main':
prog02.c:(.text+0x6a): undefined reference to `sqrt'
prog02.c:(.text+0x91): undefined reference to `atan2'
clang: error: linker command failed with exit code 1 (use -v to see invocation)
```

Բանն այն է, որ լռելությամբ կապերի խմբագրիչը (linker) կատարվող մոդուլին չի կցում մաթեմատիկական գրադարանի ֆունկցիաները։ Բայց, կոմպիլյատորի `-l` պարամետրով տալով `m` գրադարանը, կարող եմ շտկել այս իրավիճակը։

```bash
$ clang prog02.c -o prog2.c -lm
```

Հիմա արդեն ամեն ինչ կարգին է․ ֆայլը թարգմանվել է և կառուցվել է `prog02` կատարվող ֆայլը։ Գործարկեմ այն ու տեսնեմ, թե ինչ է ստացվում․

```bash
$ ./prog02
Ներածիր դեկարտյան կոորդինատները x,y․ 
3,2
Բևեռային կոորդնատներն են․ 
ρ = 3.605551, φ = 0.588003
```

Հենց որ ծրագիրն առաջարկում է ներածել `x` և `y` դեկարտյան կոորդինատները, ես ներածում եմ `3,2` թվերը։ Դրան ի պատասխան ծրագիրն արտածել է `ρ = 3.605551` և `φ = 0.588003` արժեքները։


Այս զրույցի համար էլ այսքանը։ Հաջորդ զրույցում կպատմեմ ֆունկցիաների սահմանման, դրանց արգումենտների ու վերադարձրած արժեքի մասին։


