# Զրույց VIII

Հարգելի՛ ընթերցող։

Այս զրույցը տողերի մասին է։

C լեզվում *տողը* պարզապես նիշերի զանգված է, որի վերջին տարրը `0` է (կամ `'\0'`)։ Օրինակ, հետևյալ համարժեք հրամանները սահմանում են `h0`, `h1`, `h2` և `h3` տողերը՝ նույն `String` արժեքով․

```c
char h0[] = { 'S', 't', 'r', 'i', 'n', 'g', '\0' };
char h1[] = "String";
char h2[7] = "String";
char* h3 = "String";
```

Երբ նիշերի զանգվածն արժեքավորվում է *տողային լիտերալով* (`"..."` գրառմամբ), զանգվածի վերջին `'\0'` նիշն ավտոմատ ավելացվում է։ Այս փաստը պետք է հաշվի առնել այն դեպքում, երբ զանգվածի չափը բացահայտ նշվում է (ինչպես, օրինակ, `h2` փոփոխականի դեպքում)։

C լեզվի ստանդարտ գրադարանի `string.h` ֆայլը պարունակում է տողերի հետ աշխատող ֆունկցիաների հայտարարությունները։ Այդ ֆունկցիաներից շատերն աշխատում են `char*` տիպի ցուցիչների հետ՝ նկատի ունենալով այն փաստը, որ տողն ավարտվում է `'\0'` նիշով։

Օրինակ, եթե գրադարանում արդեն սահմանված չլիներ, տողի երկարությունը հաշվող `strlen` ֆունկցիան, ապա սկսնակ ու անփորձ ծրագրավորողը կարող էր այն իրականացնել մոտավոերապես հետևյալ կերպ․

```c
int strlen0( char* str )
{
  int count = 0; /* նիշերի քանակ */
  while( str[count] != '\0' ) /* քանի դեռ նիշը '\0' չէ */
    ++count; /* ավելացնել հաշվիչը */
  return count;
}
```

Ավելի փորձառու ծրագրավորողը կօգտագործի ցուցիչների հետ կատարվող թվաբանությունը։

```c
size_t strlen1( const char* s )
{
  const char* p = s; /* սկսել ցուցակի սկզբից */
  while( *++p ); /* քանի դեռ p-ն '\0' նիշի վրա չէ, առաջ տանել այն */
  return p - s; /* վերադարձնել երկու ցուցիչների տարբերությունը */
}
```

Ֆունկցիայի վերադարձրած արժեքի համար ընտրված է առանց նշանի ամբողջ թվերի `size_t` տիպը, որը նախատեսված է որպես չափեր ու երկարություններ ցույց տվող ունիվերսալ տիպ։

Երկու տողեր համեմատվում են `strcmp` ֆունկցիայով։ Այս ֆունցկիան կատարում է արգումենտում տրված երկու տողերի _բառարանային_ համեմատում։ Եթե երկու տողերի պարունակությունը համընկնում է `strcmp` ֆունկցիան վերադարձնում է `0`։ Եթե առաջինի արժեքը բառարանային կարգով ավելի փոքր է երկրորդի արժեքից, ապա վերադարձվում է բացասական արժեք, իսկ եթե մեծ է՝ դրական արժեք։ `strncmp` ֆունկցիայի երրորդ արգումենտով նշվում է, թե երկու տողերի սկզբից քանի նիշ պետք է համեմատել։


`strchr` ֆունկցիան իր առաջին արգումենտում տրված տողում որոնում է երկրորդ արգումենտում տրված նիշը։ Այս ֆունկցիան վերդարձնում է գտնված նիշի ցուցիչը, կամ `NULL`՝ եթե այդպիսին չի գտնվել։ Օրինակ․

```c
char* s0 = "One String";
char* s1 = strchr( s0, 'S' );
puts( s1 ); // արտածում է String
```

Տողի մեջ մի այլ տող որոնելու համար է նախատեսված `strstr` ֆունկցիան։ Այն իր առաջին արգումենտում տրված տողի մեջ որոնում է երկրորդ արգումետում տրված ենթատողը։ `strstr` ֆունկցիան գտված ենթատողի առաջին նիշի ցուցիչը, կամ `NULL`՝ եթե ենթատողը չի գտնվել։ Օրինակ․

```c
char* s2 = "One long string";
char* s3 = strstr( s2, "long" );
puts( s3 ); // արտածում է long string
```

Մի տողը մի այլ տողի մեջ պատճենվում է `strcpy` ֆունկցիայով։ Այս ֆունկցիայի երկրորդ արգումենտի պարունակությունը պատճենվում է առաջինի մեջ։ Օրինակ․

```c
char* h4 = "One string";
char h5[11] = { 0 };
strcpy( h5, h4 );
puts( h5 ); // արտածվում է One string
```

Մի տողից տրված քանակով նիշեր մեկ այլ տողի մեջ պատճենվում են `strncpy` ֆունկցիայով։ Օրինակ, այսպես․

```c
char* h6 = "0123456789";
char h7[11] = { 0 };
strncpy( h7, h6, 5 );
puts( h7 ); // արտածվում է 01234
```

Եթե պետք է մի տողին կցել մի այլ տող, ապա օգտագործվում են `strcat` և `strncat` ֆունկցիաներ։ Առաջինը կցում է ամբողջ տողը, իսկ երկրորդը՝ միայն տրված քանակով նիշեր։ Օրինակ․

```c
char s4[64] = { 0 };
strcpy( s4, "One" );
puts( s4 ); // արտածվում է One
strcat( s4, ", Two" );
puts( s4 ); // արտածվում է One, Two
strncat( s4, ", Three, Four", 7 );
puts( s4 ); // արտածվում է One, Two, Three
```


----

Երբ զրույցներից մեկում պատմեցի `main` ֆունկցիայի մասին, ես հետաձգեցի նրա պարամետրերի մասին խոսակցությունը մինչև այն պահը, երբ կպատմեմ տողերի ու ցուցիչների մասին։ 
Բանն այն է, որ `main` ֆունկցիան կարող է սահմանվել նաև երկու պարամետրերով՝ հրամանային տողում տրված արգումենտների քանակը, և այդ արգումենտների արժեքների զանգվածը։ 

```c
int main( int, char** );
```

Քանի որ հրամանային տողի արգումենտները փոխանցվում են որպես տողեր, `main` ֆունկցիայի երկրորդ արգումենտը հայտարարված է որպես `char**`։

Linux համակարգերում հայտնի `echo` հրամանի մի պարզագույն տարբերակ կարելի է իրականացնել հետևյալ կերպ։

```c
#include <stdio.h>

int main( int argc, char** argv )
{
  for( int c = 1; c < argc; ++c )
    puts( argv[c] );

  return 0;
}
```

`argc` պարամետրը ցույց է տալիս, թե քանի արգումենտ է եղել հրամանային տողում՝ ներառյալ գործարկվող ծրագիր անունը։ Օրինակ, վերը բերված ծրագիրը ես գրել եմ `prog08b.c` ֆայլում և կոմպիլյացիայի արդյունքում ստեղծել եմ `prog08b` կատարվող ֆայլը։ Եթե այն գործարկեմ հետևյալ կերպ․

```bash
$ ./prog08b abcd 123 'efgh 45'
```

ապա սա կնշանակի, որ `argc` պարամետրի արժեքը `4` է, իսկ `argv` զանգվածն ունի այսպիսի տեսք․

```
     +-------+----+---+-------+
argv |prog08b|abcd|123|efgh 45|
     +-------+----+---+-------+
         0      1   2     3
```


