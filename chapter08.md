# Զրույց VIII

Հարգելի՛ ընթերցող։

Այս զրույցը տողերի մասին է։

C լեզվում *տողը* պարզապես նիշերի զանգված է, որի վերջին տարրը `0` է (կամ `'\0'`)։ Օրինակ, հետևյալ համարժեք հրամանները սահմանում են `h0`, `h1`, `h2` և `h3` տողերը՝ նույն `String` արժեքով․

```c
char h0[] = { 'S', 't', 'r', 'i', 'n', 'g', '\0' };
char h1[] = "String";
char h2[7] = "String";
char* h3 = "String";
```

Երբ նիշերի զանգվածն արժեքավորվում է *տողային լիտերալով* (`"..."` գրառմամբ), զանգվածի վերջին `'\0'` նիշն ավտոմատ ավելացվում է։ Այս փաստը պետք է հաշվի առնել այն դեպքում, երբ զանգվածի չափը բացահայտ նշվում է (ինչպես, օրինակ, `h2` փոփոխականի դեպքում)։

C լեզվի ստանդարտ գրադարանի `string.h` ֆայլը պարունակում է տողերի հետ աշխատող ֆունկցիաների հայտարարությունները։ Այդ ֆունկցիաներից շատերն աշխատում են `char*` տիպի ցուցիչների հետ՝ նկատի ունենալով այն փաստը, որ տողն ավարտվում է `'\0'` նիշով։

Օրինակ, եթե գրադարանում արդեն սահմանված չլիներ, տողի երկարությունը հաշվող `strlen` ֆունկցիան, ապա սկսնակ ու անփորձ ծրագրավորողը կարող էր այն իրականացնել մոտավոերապես հետևյալ կերպ․

```c
int strlen0( char* str )
{
  int count = 0; /* նիշերի քանակ */
  while( str[count] != '\0' ) /* քանի դեռ նիշը '\0' չէ */
    ++count; /* ավելացնել հաշվիչը */
  return count;
}
```

Ավելի փորձառու ծրագրավորողը կօգտագործի ցուցիչների հետ կատարվող թվաբանությունը։

```c
size_t strlen1( const char* s )
{
  const char* p = s; /* սկսել ցուցակի սկզբից */
  while( *++p ); /* քանի դեռ p-ն '\0' նիշի վրա չէ, առաջ տանել այն */
  return p - s; /* վերադարձնել երկու ցուցիչների տարբերությունը */
}
```

Ֆունկցիայի վերադարձրած արժեքի համար ընտրված է առանց նշանի ամբողջ թվերի `size_t` տիպը, որը նախատեսված է որպես չափեր ու երկարություններ ցույց տվող ունիվերսալ տիպ։

Երկու տողեր համեմատվում են `strcmp` ֆունկցիայով։ Այս ֆունցկիան կատարում է արգումենտում տրված երկու տողերի _բառարանային_ համեմատում։ Եթե երկու տողերի պարունակությունը համընկնում է `strcmp` ֆունկցիան վերադարձնում է `0`։ Եթե առաջինի արժեքը բառարանային կարգով ավելի փոքր է երկրորդի արժեքից, ապա վերադարձվում է բացասական արժեք, իսկ եթե մեծ է՝ դրական արժեք։ `strncmp` ֆունկցիայի երրորդ արգումենտով նշվում է, թե երկու տողերի սկզբից քանի նիշ պետք է համեմատել։


`strchr` ֆունկցիան իր առաջին արգումենտում տրված տողում որոնում է երկրորդ արգումենտում տրված նիշը։ Այս ֆունկցիան վերդարձնում է գտնված նիշի ցուցիչը, կամ `NULL`՝ եթե այդպիսին չի գտնվել։ Օրինակ․

```c
char* s0 = "One String";
char* s1 = strchr( s0, 'S' );
puts( s1 ); // արտածում է String
```

Տողի մեջ մի այլ տող որոնելու համար է նախատեսված `strstr` ֆունկցիան։ Այն իր առաջին արգումենտում տրված տողի մեջ որոնում է երկրորդ արգումետում տրված ենթատողը։ `strstr` ֆունկցիան գտված ենթատողի առաջին նիշի ցուցիչը, կամ `NULL`՝ եթե ենթատողը չի գտնվել։ Օրինակ․

```c
char* s2 = "One long string";
char* s3 = strstr( s2, "long" );
puts( s3 ); // արտածում է long string
```

Մի տողը մի այլ տողի մեջ պատճենվում է `strcpy` ֆունկցիայով։ Այս ֆունկցիայի երկրորդ արգումենտի պարունակությունը պատճենվում է առաջինի մեջ։ Օրինակ․

```c
char* h4 = "One string";
char h5[11] = { 0 };
strcpy( h5, h4 );
puts( h5 ); // արտածվում է One string
```

Մի տողից տրված քանակով նիշեր մեկ այլ տողի մեջ պատճենվում են `strncpy` ֆունկցիայով։ Օրինակ, այսպես․

```c
char* h6 = "0123456789";
char h7[11] = { 0 };
strncpy( h7, h6, 5 );
puts( h7 ); // արտածվում է 01234
```

Եթե պետք է մի տողին կցել մի այլ տող, ապա օգտագործվում են `strcat` և `strncat` ֆունկցիաներ։ Առաջինը կցում է ամբողջ տողը, իսկ երկրորդը՝ միայն տրված քանակով նիշեր։ Օրինակ․

```c
char s4[64] = { 0 };
strcpy( s4, "One" );
puts( s4 ); // արտածվում է One
strcat( s4, ", Two" );
puts( s4 ); // արտածվում է One, Two
strncat( s4, ", Three, Four", 7 );
puts( s4 ); // արտածվում է One, Two, Three
```

----

Տողերի հետ աշխատող ֆունկցիաները ցուցադրելու համար ներկայացնեմ բավականին հայտնի մի խնդիր։ Տրված է `1..999999` միջակայքի մի դրական ամբողջ թիվ և պահանջվում է կառուցել նրա բառային արտահայտությունը։ Օրինակ, եթե տրված է «428», ապա պետք է կառուցել «չորս հարյուր քսանութ» տողը։ Այս խնդրի լուծման ալգորիթմն այնքան պարզ է, որ նույնիսկ ամոթ էլ է դրան «ալգորիթմ» ասել։

Եվ այսպես, թող որ `num` թվի թվային տեսքից բառային տեքսքը ստացող ֆունկցիան ունի հետևյալ հայտարարությունը, առաջին արգումենտը թիվն է, իսկ երկրորդ արգումենտն այն բուֆերն է, որտեղ պետք է գրվի պատասխանը։ 

```c
void number_as_words( int, char* );
```

Մի քիչ առաջ ընկնելով սահմանեմ `number_as_words` ֆունկցիան տեստավորող `test_number_as_words` ֆունկցիան, որը ստանում է թիվ և այդ թվի սպասվող բառային տեսքը։

```c
void test_number_as_words( int number, const char* expected )
{
  char result[128] = { 0 }; /* պատասխանի բուֆեր */
  number_as_words( number, result ); /* թարգմանություն */
  if( 0 != strcmp( result, expected ) )  /* համեմատում սպասվող արժեքի հետ */
    printf( "ՍԽԱԼ։ %d թվի համար\n սպասվում է '%s'\n  ստացվել է '%s'\n", 
	    number, expected, result );
}
```

ՈՒնենալով `number_as_words` և `test_number_as_words` ֆունկցիաները, իմ ծրագրում պետք է կատարվեն հետևյալ արտահայտությունները և ոչ մի սխալի հաղորդագրություն չպետք է արտածվի։

```c
test_number_as_words( 1, "մեկ" );
test_number_as_words( 9, "ինն" );
test_number_as_words( 11, "տասնմեկ" );
test_number_as_words( 96, "ինսունվեց" );
test_number_as_words( 964, "ինն հարյուր վաթսունչորս" );
test_number_as_words( 9610, "ինն հազար վեց հարյուր տաս" );
test_number_as_words( 24531, "քսանչորս հազար հինգ հարյուր երեսունմեկ" );
test_number_as_words( 110310, "մեկ հարյուր տաս հազար երեք հարյուր տաս" );
```

Հիմա հենց `number_as_words` ֆունկցիայի մասին։ Նախ սահմանեմ երկու գլոբալ ստատիկ զանգվածներ, որոնք օգտագործվելու են ֆունկցիայի մեջ։ Դրանցից առաջինը պարունակում է միանիշ թվերի անունները (բազի զրոյից, որովհետև նրա անունը պետք չի գալիս), իսկ երկրորդը պարունակում է տասնավորների անունները։

```c
static const char* ones[] = {
  "", "մեկ", "երկու", "երեք", "չորս", 
  "հինգ", "վեց", "յոթ", "ութ", "ինն" };

static const char* tens[] = {
  "", "տաս", "քսան", "երեսուն", "քառասուն", "հիսուն", 
  "վաթսուն", "յոթանասուն", "ութսուն", "ինսուն" };
```

Նաև սահմանել `ord` մակրոսը, որը պետք է օգտագործեմ թվանշանի նիշային (char) տեսքից նրա տասական արժեքը ստանալու համար։

```c
#define ord(c) (c-'0')
```

Քանի որ ձևափոխությունը սահմանափակվելու է միայն `[1..999999]` միջակայքի թվերի համար, `sprintf` ֆունկցիայով ֆորմատավորում եմ տրված թիվը՝ հատկացնելով նրան 6 դիրք։

```c
void number_as_words( int num, char* wnum )
{
  char snum[7] = { 0 };
  sprintf( snum, "%6d", num );
```

Այս հրամաննի կատարումից հետո, օրինակ, `304` թիվը `snum` բուֆերում կունենա `␣␣␣304\0` տեսքը։ (Այստեղ `␣` նիշն օգտագործել եմ _բացատ_ նիշի դիրքոեը ցույց տալու համար։)

```
       0   1   2   3   4   5   6
     +---+---+---+---+---+---+----+
snum | ␣ | ␣ | ␣ | 3 | 0 | 4 | \0 |
     +---+---+---+---+---+---+----+
        > 1000   |  < 1000 
```

Հերթականորեն վերլուծում եմ `snum` բուֆերի `0`-ից `5` ինդեքսով դիրքերը և `wnum` տողին եմ կցում համապատսխան արտահայտությունը։

Եթե `snum[0] != ' '`, ապա պետք է արտածել միավորի անունը և «հարյուր» բառը։ Միավորի անունը վերցնում եմ `ones` վեկտորից՝ արպես ինդեքս օգտագործելով `snum[0]` թվանշանի թվային արժեքը։

```c
  if( snum[0] != ' ' ) {
    strcpy( wnum, ones[ord(snum[0])] );
    strcat( wnum, " հարյուր " );
  }
```

Եթե `snum[1] != ' '`, ապա պետք է արտածել համապատասխան տասնյակի անունը՝ միայն «տաս» բառից հետո ավելացնելով «ն» տառը։ 

```c
  if( snum[1] != ' ' ) {
    strcat( wnum, tens[ord(snum[1])] );
	if( snum[1] == '1' && snum[2] != '0' )
		strcat( wnum, "ն" );
  }
```

Եթե `snum[2] != ' '`, ապա պետք է արտածել միավորի անուննը։

```c
  if( snum[2] != ' ' )
    strcat( wnum, ones[ord(snum[2])] );
```

Այս կետում ավարտեցի թվի առաջին կեսի վերլուծությունը։ Հիմա պետք է ստուգել արդյո՞ք վերլուծվող թիվը մեծ է հազարից։ Եթե այո, ապա արտածել «հազար» բառը` երկու կողմերից ավելացնելով բացատանիշեր։

```c
  if( num >= 1000 )
    strcat( wnum, " հազար " );
```

Շարունակում եմ թվանշանների վերլուծությունը թվի երկրորդ կեսի համար, որը ճիշտ նման է առաջին կեսի վերլուծությանը՝ այն տարբերությամբ միայն, որ `snum` վեկտորի `0`, `1` և `2` ինդեքսների փոխարեն օգտագործվում են համապատասխանաբար `3`, `4` և `5` ինդեքսները։

```c
if( snum[3] != ' ' ) {
    strcat( wnum, ones[ord(snum[3])] );
    if( snum[3] != '0' || num < 1000 )
      strcat( wnum, " հարյուր " );
  }

  if( snum[4] != ' ' ) {
    strcat( wnum, tens[ord(snum[4])] );
  	if( snum[4] == '1' && snum[5] != '0' )
		strcat( wnum, "ն" );
  }

  if( snum[5] != ' ' )
    strcat( wnum, ones[ord(snum[5])] );
}
```

----

Երբ զրույցներից մեկում պատմեցի `main` ֆունկցիայի մասին, ես հետաձգեցի նրա պարամետրերի մասին խոսակցությունը մինչև այն պահը, երբ կպատմեմ տողերի ու ցուցիչների մասին։ 
Բանն այն է, որ `main` ֆունկցիան կարող է սահմանվել նաև երկու պարամետրերով՝ հրամանային տողում տրված արգումենտների քանակը, և այդ արգումենտների արժեքների զանգվածը։ 

```c
int main( int, char** );
```

Քանի որ հրամանային տողի արգումենտները փոխանցվում են որպես տողեր, `main` ֆունկցիայի երկրորդ արգումենտը հայտարարված է որպես `char**`։

Linux համակարգերում հայտնի `echo` հրամանի մի պարզագույն տարբերակ կարելի է իրականացնել հետևյալ կերպ։

```c
#include <stdio.h>

int main( int argc, char** argv )
{
  for( int c = 1; c < argc; ++c )
    puts( argv[c] );

  return 0;
}
```

`argc` պարամետրը ցույց է տալիս, թե քանի արգումենտ է եղել հրամանային տողում՝ ներառյալ գործարկվող ծրագիր անունը։ Օրինակ, վերը բերված ծրագիրը ես գրել եմ `prog08b.c` ֆայլում և կոմպիլյացիայի արդյունքում ստեղծել եմ `prog08b` կատարվող ֆայլը։ Եթե այն գործարկեմ հետևյալ կերպ․

```bash
$ ./prog08b abcd 123 'efgh 45'
```

ապա սա կնշանակի, որ `argc` պարամետրի արժեքը `4` է, իսկ `argv` զանգվածն ունի այսպիսի տեսք․

```
     +-------+----+---+-------+
argv |prog08b|abcd|123|efgh 45|
     +-------+----+---+-------+
         0      1   2     3
```


