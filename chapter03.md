# Զրույց III

Հարգելի՛ ընթերցող։

Իմ երրորդ զրույցը նվիրված է C ծրագրավորման լեզվի ֆունկցիաներին։ Այս անգամ ես կպատմեմ նոր ֆունկցիաների հայտարարման ու սահմանման մասին, ֆունկցիայի արգումենտների ու վերադարձրած արժեքի մասին։

Ինչպես և մաթեմատիկայում, որտեղից էլ եկել է *ֆունկցիա* տերմինը, C լեզվում էլ ֆունկցիաները նախատեսված են տվյալների մի բազմությունը մեկ այլ բազմության արտապատկերելու համար։ Օրինակ, նախորդ զրույցում հիշատակված `sqrt` ֆունկցիան արգումենտում սպասում է `double` տիպի արժեք և վերադարձնում է այդ արժեքի երկրորդ աստիճանի արմատը՝ նորից `double` տիպի արժեք։ Կարող եմ ասել, որ `sqrt` ֆունկցիան `double` արժեքների բազմությունն արտապատկերում է նույն արժեքների `double` բազմությանը։ Մաթեմատիկորեն այդ փաստը սովորաբար գրառվում է հետևյալ կերպ․

```
sqrt : double ↦ double
```

Իսկ C լեզվով այս նույն *հայտարարությունը* գրառվում է այսպես․

```c
double sqrt( double );
``` 

Մեկ այլ օրինակ է նորից նախորդ զրույցում հիշատակված `atan2` ֆունկցիան։ Այն արգումենտում սպասում է երկու `double` թվեր՝ կետի կոորդինատները և վերադարձնում է աբսցիսների առանցքի և կոորդինատների սկզբնակետով ու տրված կետով անցնող ուղղի կազմած անկյունը՝ նորից `double` թիվ՝ `(−π, π]` միջակայքից։ Մաթեմատիկական գրառումը հետևյալն է․

```
atan2 : double ⨯ double ↦ double
```

C լեզվով գրառումն էլ այսպիսինն է․

```c
double atan2( double, double );
```

Եվ այսպես․ C ծրագրավորման լեզվում ֆունկցիայի հայտարարությունն ունի երեք բաղադրիչ․ *վերադարձվող արժեքի տիպ*, *ֆունկցիայի անուն* և *արգումենտների տիպերի ցուցակ*։ Վերադարձվող արժեքի տիպը և արգումենտների տիպն իրար հետ կոչվում է *ֆունկցիայի տիպ*։

> Երբեմն ֆունկցիայի տիպ են անվանում վրա վերադարձրած արժեքի տիպը։ Բնականաբար դա սխալ է, որովհետև միայն վերադարձվող արժեքի տիպը չի կարող միարժեքորեն որոշել ֆունկցիայի տիպը։

Ինչպես փոփոխականների դեպքում, այնպես էլ ֆունկցիաներն է պետք օգտագործումից առաջ հայտարարել։ Բայց C լեզվում հայտարարելուց բացի պետք է նաև *սահմանել* ֆունկցիաների վարքը՝ այն գործողությունները, որ ֆունկցիան կատարում է *որոշման տիրույթն* *արժեքների տիրույթին* արտապատկերելու համար։ Ֆունկցիայի վարքը սահմանվում է `{` և `}` նիշերի մեջ առնված հրամանների հաջորդականությամբ, որը գրվում է ֆունկցիայի *վերդագրից* հետո։ Օրինակ, նախորդ զրույցում դեկարտյան կոորդինատներից բևեռային կոորդինատները ստանալու համար օգտագործեցի երկու բանաձև՝ կետի շառավիղը և ազիմուտը հաշվող կանոնները։ Կարող եմ սահմանել, օրինակ, `radius` ֆունկցիան հետևյալ կերպ․

```c
/* շառավղի հաշվումը դեկարտյան կոորդինատներով */
double radius( double x, double y )
{
  return sqrt( x * x + y * y );
}
``` 

C լեզվի `return` հրամանը ֆունկցիայից արժեք վերադարձնող գործողությունն է։ Յուրաքանչյուր ֆունկցիա պարտավոր է ունենալ գոնե մեկ `return` հրաման և այդ հրամանի արգումենտն էլ հենց ֆունկցիայի արժեքն է։ (Բացառությամբ այն դեպքերի, երբ ֆունկցիայի վերադարձրած արժեքի տիպը `void` է։ Այդ մասին դեռ կզրուցենք։)

`radius` ֆունկցիայի պես կարող եմ սահմանել նաև `azimuth` ֆունկցիան․

```c
/* ազիմուտի հաշվումը դեկարտյան կոորդինատներով */
double azimuth( double x, double y )
{
  return atan2( y, x );
}
```

> Բայց սրանք երկուսն էլ շատ պարզ ֆունկցիաներ են և, կոնկրետ այս դեպքում, կարող եմ յոլա գնալ առանց նոր ֆունկցիաների սահմանման։

C լեզվում ֆունկցիայի սահմանումն ունի չորս բաղադրիչ․ *վերադարձվող արժեքի տիպ*, *անուն*, *արգումենտների հայտարարության ցուցակ* և *մարմին*։

Արդեն օրիակում գրեցի, թե ինչպես են ֆունկցիայի սահմանման մեջ թվարկվում արգումենտները․ նախ՝ տիպը, հետո՝ անունը։ Ամեն մի արգումենտից առաջ պետք է գրել իր տիպը։ Եթե `x`, `y` և `z` փոփոխականները թույլատրելի է հայտարարել մեկ հրամանով՝

```c
float x, y, z;
```

ապա ֆունկցիայի սահմանման ժամանակ չի կարելի գրել հետևյալը․

```c
? int f( int x, y, z )
? {
?  return x + y + z;
? }
```

> `?` նիշերով ես երբեմն կնշեմ սխալ ծրագրերը։


Երբ խոսում էի `scanf` ֆունկցիայի մասին, ասացի, որ այն ըստ տրված ֆորմատի կարդացած արժեքները գրում է առաջինից բացի հաջորդ արգումենտներով տրված *հասցեներում*։ Հիմա ուզում եմ պատմել, թե ինչպես են հայտարարվում և օգտագործվում փոփոխականների հասցեները։

Եթե ուզում եմ ծրագրում հայտարարել, որ պատրաստվում եմ `a0` փոփոխականին վերագրել ամբողջ թվեր (`int`), իսկ `a1` փոփոխականին՝ նիշեր (`char`), ապա պետք է գրեմ․

```c
int a0 = 777;
char a1 = 'A';
```

Եթե ուզում եմ հայտարարել, որ `p0` փոփոխականին վերագրելու եմ ամբողջաթիվ (`int`) փոփոխականի հասցե, իսկ `p1` փոփոխականին՝ նիշային (`char`) փոփոխականի հասցե, ապա պետք է գրեմ․

```c
int* p0 = &a0;   /* p0-ն արժեքավորել a0-ի հասցեով */
char* p1 = &a1;  /* p1-ը արժեքավորել a1-ի հասցեով */
```

Այս նոր գրելաձևը, երբ տիպի անունից հետո գրված է `*` նիշը, հենց *ցուցիչի* հայտարարման ձևն է, իսկ `&` գործողությունը փոփոխականի հասցեն վերցնելու գործողությունն է։ 

Հիմա կարող եմ `a0` և `a1` փոփոխականներին արժեք վերագրել ոչ թե ուղղակիորեն, այլ նրանց հասցեի միջոցով։ Օրինակ այսպես․

```c
*p0 = 888;  /* a0-ին վերագրել 888 */
*p1 = 'B';  /* a1-ին վերագրել 'B' */
```

Այս դեպքում արդեն `*` գործողությունը կոչվում է *ապահասցեավորման* գործողություն (ինչ որ իմաստով այն `&` գործողության հակադիրն է)։

Սա իմանալով կարող եմ սահմանել մի նոր ֆունկցիա, որը, ստանալով կետի դեկարտյան կոորդինատները, վերադարձնում է նույն այդ կետի բևեռային կոորդինատները։ Բայց վերադարձնում է ոչ թե որպես ֆունկցիայի արժեք, այլ հաշվարկած արժեքները գրում է տրված հասցեներում։

```c
void polar( double x, double y, double* rho, double* phi )
{
  *rho = sqrt( x * x + y * y );
  *phi = atan2( y, x );
}
```

Այս ֆունկցիան ստանում է երկու իրական թիվ, որոնք ֆունկցիայի արգումենտներն են, և իրական թվերի երկու ցուցիչներ, որոնք, ըստ էության, `polar` ֆունկցիայի վերադարձվող արժեքներն են։ `polar` ֆունկցիան օգտագործվում է ճիշտ այնպես, ինչպես օգտագործվում էր `scanf` ֆունկցիան՝ ստեղնաշարից կոորդինատների կարդալու ժամանակ․

```c
double x = 0.0, y = 0.0;
scanf( "%lf,%lf", &x, &y );

double rho = 0.0, phi = 0.0;
polar( x, y, &rho, &phi );
```

Քանի որ `polar` ֆունկցիան արժեքները վերադարձնում է որպես ցուցիչ տրված արգումենտների միջոցով, պետք է սահմանման մեջ նշել, որ այս ֆունկցիան սովորական իմաստով վերադարձվող արժեք չունի և չի օգտագործելու `return` հրամանը։ Ես դա արել եմ ֆունկցիայի տիպը նշելով որպես `void`։






















